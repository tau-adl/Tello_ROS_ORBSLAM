// Generated by gencpp from file flock_msgs/FlightData.msg
// DO NOT EDIT!


#ifndef FLOCK_MSGS_MESSAGE_FLIGHTDATA_H
#define FLOCK_MSGS_MESSAGE_FLIGHTDATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace flock_msgs
{
template <class ContainerAllocator>
struct FlightData_
{
  typedef FlightData_<ContainerAllocator> Type;

  FlightData_()
    : battery_percent(0)
    , estimated_flight_time_remaining(0.0)
    , flight_mode(0)
    , flight_time(0.0)
    , east_speed(0.0)
    , north_speed(0.0)
    , ground_speed(0.0)
    , altitude(0.0)
    , equipment(0)
    , high_temperature(false)
    , em_ground(false)
    , em_open(false)
    , em_sky(false)
    , pitch(0.0)
    , roll(0.0)
    , yaw(0.0)
    , agx(0.0)
    , agy(0.0)
    , agz(0.0)  {
    }
  FlightData_(const ContainerAllocator& _alloc)
    : battery_percent(0)
    , estimated_flight_time_remaining(0.0)
    , flight_mode(0)
    , flight_time(0.0)
    , east_speed(0.0)
    , north_speed(0.0)
    , ground_speed(0.0)
    , altitude(0.0)
    , equipment(0)
    , high_temperature(false)
    , em_ground(false)
    , em_open(false)
    , em_sky(false)
    , pitch(0.0)
    , roll(0.0)
    , yaw(0.0)
    , agx(0.0)
    , agy(0.0)
    , agz(0.0)  {
  (void)_alloc;
    }



   typedef int32_t _battery_percent_type;
  _battery_percent_type battery_percent;

   typedef float _estimated_flight_time_remaining_type;
  _estimated_flight_time_remaining_type estimated_flight_time_remaining;

   typedef uint8_t _flight_mode_type;
  _flight_mode_type flight_mode;

   typedef float _flight_time_type;
  _flight_time_type flight_time;

   typedef float _east_speed_type;
  _east_speed_type east_speed;

   typedef float _north_speed_type;
  _north_speed_type north_speed;

   typedef float _ground_speed_type;
  _ground_speed_type ground_speed;

   typedef float _altitude_type;
  _altitude_type altitude;

   typedef int32_t _equipment_type;
  _equipment_type equipment;

   typedef uint8_t _high_temperature_type;
  _high_temperature_type high_temperature;

   typedef uint8_t _em_ground_type;
  _em_ground_type em_ground;

   typedef uint8_t _em_open_type;
  _em_open_type em_open;

   typedef uint8_t _em_sky_type;
  _em_sky_type em_sky;

   typedef float _pitch_type;
  _pitch_type pitch;

   typedef float _roll_type;
  _roll_type roll;

   typedef float _yaw_type;
  _yaw_type yaw;

   typedef float _agx_type;
  _agx_type agx;

   typedef float _agy_type;
  _agy_type agy;

   typedef float _agz_type;
  _agz_type agz;



  enum {
    flight_mode_ground = 1u,
    flight_mode_hover = 6u,
    flight_mode_taking_off = 11u,
    flight_mode_landing = 12u,
    flight_mode_spinning_up = 41u,
    equipment_ok = 0,
    equipment_unstable = 21,
    equipment_timer_exceeded = 205,
  };


  typedef boost::shared_ptr< ::flock_msgs::FlightData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::flock_msgs::FlightData_<ContainerAllocator> const> ConstPtr;

}; // struct FlightData_

typedef ::flock_msgs::FlightData_<std::allocator<void> > FlightData;

typedef boost::shared_ptr< ::flock_msgs::FlightData > FlightDataPtr;
typedef boost::shared_ptr< ::flock_msgs::FlightData const> FlightDataConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::flock_msgs::FlightData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::flock_msgs::FlightData_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace flock_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'flock_msgs': ['/home/arkadiros/ROS/tello_catkin_ws/src/flock/flock_msgs/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::flock_msgs::FlightData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::flock_msgs::FlightData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::flock_msgs::FlightData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::flock_msgs::FlightData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flock_msgs::FlightData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flock_msgs::FlightData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "1fbfcd738c3afa96d840f05b5d17f7de";
  }

  static const char* value(const ::flock_msgs::FlightData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x1fbfcd738c3afa96ULL;
  static const uint64_t static_value2 = 0xd840f05b5d17f7deULL;
};

template<class ContainerAllocator>
struct DataType< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "flock_msgs/FlightData";
  }

  static const char* value(const ::flock_msgs::FlightData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Flight data -- experimental -- will change as we learn more\n\
# Gobot code seems to be the best reference\n\
\n\
# Battery state:\n\
int32 battery_percent                     # Remaining battery, 0-100\n\
float32 estimated_flight_time_remaining   # Remaining flight time, seconds\n\
\n\
# Flight modes:\n\
uint8 flight_mode_ground=1          # Motors off\n\
uint8 flight_mode_hover=6           # Hovering\n\
uint8 flight_mode_taking_off=11     # Taking off\n\
uint8 flight_mode_landing=12        # Landing\n\
uint8 flight_mode_spinning_up=41    # Spinning up the props, will take off soon\n\
uint8 flight_mode\n\
\n\
# Flight time:\n\
float32 flight_time                 # Flight time since power up, in seconds\n\
\n\
# Position and velocity, negative numbers mean \"no data\":\n\
float32 east_speed                  # meters/second\n\
float32 north_speed                 # meters/second\n\
float32 ground_speed                # meters/second\n\
float32 altitude                    # Height off the ground in meters\n\
\n\
# Equipment status:\n\
int32 equipment_ok=0                # Everything is OK\n\
int32 equipment_unstable=21         # The drone is unstable, tilted at an odd angle or upside down\n\
int32 equipment_timer_exceeded=205  # No input for 15 seconds, shutting down\n\
int32 equipment\n\
\n\
# Temperature:\n\
bool high_temperature               # It's getting warm in here\n\
\n\
# ???\n\
bool em_ground                      # ???\n\
bool em_open                        # ???\n\
bool em_sky                         # ???\n\
\n\
\n\
float32 pitch\n\
float32 roll\n\
float32 yaw\n\
float32 agx\n\
float32 agy\n\
float32 agz\n\
";
  }

  static const char* value(const ::flock_msgs::FlightData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::flock_msgs::FlightData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.battery_percent);
      stream.next(m.estimated_flight_time_remaining);
      stream.next(m.flight_mode);
      stream.next(m.flight_time);
      stream.next(m.east_speed);
      stream.next(m.north_speed);
      stream.next(m.ground_speed);
      stream.next(m.altitude);
      stream.next(m.equipment);
      stream.next(m.high_temperature);
      stream.next(m.em_ground);
      stream.next(m.em_open);
      stream.next(m.em_sky);
      stream.next(m.pitch);
      stream.next(m.roll);
      stream.next(m.yaw);
      stream.next(m.agx);
      stream.next(m.agy);
      stream.next(m.agz);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct FlightData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::flock_msgs::FlightData_<ContainerAllocator>& v)
  {
    s << indent << "battery_percent: ";
    Printer<int32_t>::stream(s, indent + "  ", v.battery_percent);
    s << indent << "estimated_flight_time_remaining: ";
    Printer<float>::stream(s, indent + "  ", v.estimated_flight_time_remaining);
    s << indent << "flight_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.flight_mode);
    s << indent << "flight_time: ";
    Printer<float>::stream(s, indent + "  ", v.flight_time);
    s << indent << "east_speed: ";
    Printer<float>::stream(s, indent + "  ", v.east_speed);
    s << indent << "north_speed: ";
    Printer<float>::stream(s, indent + "  ", v.north_speed);
    s << indent << "ground_speed: ";
    Printer<float>::stream(s, indent + "  ", v.ground_speed);
    s << indent << "altitude: ";
    Printer<float>::stream(s, indent + "  ", v.altitude);
    s << indent << "equipment: ";
    Printer<int32_t>::stream(s, indent + "  ", v.equipment);
    s << indent << "high_temperature: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.high_temperature);
    s << indent << "em_ground: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.em_ground);
    s << indent << "em_open: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.em_open);
    s << indent << "em_sky: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.em_sky);
    s << indent << "pitch: ";
    Printer<float>::stream(s, indent + "  ", v.pitch);
    s << indent << "roll: ";
    Printer<float>::stream(s, indent + "  ", v.roll);
    s << indent << "yaw: ";
    Printer<float>::stream(s, indent + "  ", v.yaw);
    s << indent << "agx: ";
    Printer<float>::stream(s, indent + "  ", v.agx);
    s << indent << "agy: ";
    Printer<float>::stream(s, indent + "  ", v.agy);
    s << indent << "agz: ";
    Printer<float>::stream(s, indent + "  ", v.agz);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FLOCK_MSGS_MESSAGE_FLIGHTDATA_H
